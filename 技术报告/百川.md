# ☁️中传放心传（CUC-cloud-disk-upload-management-system）技术报告

**一个基于Vue和springboot+mybatisplus实现的文件云盘管理系统**

[![Typing SVG](https://readme-typing-svg.herokuapp.com?size=25&duration=1486&center=%E9%94%99%E8%AF%AF%E7%9A%84&vCenter=%E9%94%99%E8%AF%AF%E7%9A%84&multiline=true&height=60&lines=%E4%B8%AD%E4%BC%A0%E6%94%BE%E5%BF%83%E4%BC%A0;CUC-cloud-disk-upload-management-system)](https://git.io/typing-svg)

**作者：百川**

**负责工作：**项目整体规划、前端页面编写、后端平台搭建、具体功能修复测试

**时间：**2022.8

**前端工作日志**：[前端开发日志](https://github.com/Xuyan-cmd/CUC-cloud-disk-upload-management-system/blob/front_end/%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97.md)

**后端工作日志**：[后端开发日志](https://github.com/Xuyan-cmd/CUC-cloud-disk-upload-management-system/blob/rear_end/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97.md)

### 前言

本次小学期的实践目标是实现一个结合本专业密码学和网络安全知识体系的一个文件管理云盘系统，要求做到有文件管理的基础功能（增删改查）以外还要融入网络空间安全专业所特有的专业知识，是一次十分有意义的并且能够挖掘自身能力和一个深度学习的过程。

对于我而言，这一个多月的开发时间里，我遇到了很多的困难和知识盲区，但在这样持续学习的一个过程中，我能够深刻意识到自己对于很多知识的匮乏，因此也是这样一个契机带动着我去学习和摸索。

在最初的计划阶段，我的设想是基于老师给出的模板进行开发，但是和小组成员进行了讨论后，大家更愿意借助这样一段时间去从0开始去搭建开发，于是我们去查阅相关资料，结合我们现有的知识储备，最终决定使用当前市场主流的开发框架和工具，前端采用当前较为火遍的**Vue框架**，后端使用近几年的新锐**SpringBoot框架**。而在具体开发过程中结合密码学知识基础和要求去完成这样一个云盘文件管理系统——**中传放心传**

我对于前端开发所使用的Vue框架有一定的基础，而对于后端的接口逻辑编写和搭建只知皮毛，因此我们小组在后端的开发过程中花费相当大的学习成本，这中间出现了很多Bug和技术壁垒，我一度曾怀疑我们是否有能力在这样短的时间内去完成这样的开发，但感谢我的组员，我们始终没有退缩，最终真的从0到完整开发出成品！虽然存在很多不完美的地方和有待商榷的技术细节，但对于我们小组每一个人而言，这段时间的学习和实践是本次小学期最大的收获和意义！

### 开发内容回顾

在这个章节，我主要列出了我在整个开发过程中印象深刻的一些内容，包括部分问题的解决思路、知识学习回顾、Bug修复的方法。

**项目主体开发思路框架：**![](https://s6.jpg.cm/2022/08/03/PQMxgX.jpg)

#### 前端开发

- **对于用户注册口令信息的密码强度校验和规则设定**

  - 为了确保用户注册时口令信息的安全强度，因此需要直接在用户注册时对其口令进行校验和规则设定，因此我选择结合element-ui的form表单工具和正则表达式去实现这样的功能逻辑，例如项目中我设定了用户的用户名限制在11位，口令长度8-36，其中口令只接受阿拉伯数字、英文字母、除-、_\、以外的字符，通过正则表达式去限制具体的内容。

  - ```typescript
    <el-form-item>
     <el-input
        v-model="registered.password"
        @input="checkPassLever"
        type="password"
        placeholder="请输入密码"
        onkeyup="value=value.replace(/[^\a-\z\A-\Z0-9\-\_\.]/g,'')"
        maxlength="36"
        minlength="8"
        show-word-limit
        ></el-input>
    ```

- **前端页面路由跳转问题的分析**

  - 在开发前端页面过程中，出现了对于路由设定的问题，当按返回键的时候页面并没有发生变化，一开始还以为是没有监听到返回事件，但是通过测试之后发现返回事件监听成功了，路由也发生了变化，相应事件也触发了，就是页面视图没有跟着改变。

  - 原因分析：项目中路由设置的是 **hash模式**，所以对 hashchange 事件进行监听hash模式下，路由的变化会触发hashchange事件）。因此要重新在app.vue文件中重新绑定路由，从而路由不会因为重复调用而导致不能改变视图。

    - ```typescript
       mounted() {
          // 检测浏览器路由改变页面不刷新问题,hash模式的工作原理是 hashchange事件
          window.addEventListener('hashchange', () => {
          let currentPath = window.location.hash.slice(1)
          if (this.$route.path !== currentPath) {
            this.$router.push(currentPath)
          }
        }, false)
      }
      
      ```

- **使用axios访问api时出现的问题**

  - **axios使用post请求服务端不能获取参数的解决方法**：

  - 项目中使用到axios作为ajax请求插件，用到post请求是常见的，但是后台说没有接收到传过去的参数，但是可以收到请求，前端检查了好几遍，浏览器的请求信息是 OK 的，请求封装也是ok的，参数都是有的，前端看是服务端的问题，服务端监测是前端的问题，这就十分抓狂。

  - 其实是axios在内部自动帮我们转换json格式数据, 也就是说，我们的 Content-Type 变成了 application/json;charset=utf-8
    然后，因为我们的参数是 JSON 对象，axios 帮我们做了一个 stringify 的处理。 而axios 使用 post 发送数据时，默认是直接把 json 放到请求体中提交到后端的。
    那么，这就与我们服务端要求的 ‘Content-Type’: ‘application/x-www-form-urlencoded’ 不符合。

    首先我尝试了给axios 头添加post请求方法的 Content-Type：

    ```typescript
    axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded'; 
    ```

    但是并没有起效果，翻了半天文档又查了一下需要序列化, qs序列化请求参数即可，当然你可以在封装请求方法的api中每次请求时作处理，我这里使用了封装axios时直接在request请求拦截器中做了处理：

    ```typescript
    import Qs from 'qs'
    axios.interceptors.request.use( (config) => {
        if (config.method=="post"){
            config.data = qs.stringify(config.data);
            config.headers['Content-Type'] = 'application/x-www-form-urlencoded';
        }
        return config;
    },  (error) => {
        return Promise.reject(error);
    });
    ```

    最后成功发送post请求，得到数据。

  - **使用axios，get数据是正常的。但是渲染数据时data一直为空解决方案：**

  - 原因;在ajax中的this会指向ajax本身，而不再是vue实例本身 ，同理，axios的then中this也不是指向vue实例本身。

    - **方法1：** 用ES6箭头函数，箭头方法可以和父方法共享变量 ( ES6中的 箭头函数 “=>” 内部的this是词法作用域，由上下文确定(也就是由外层调用者vue来确定) )

    - ```typescript
      axios({
                  method:'get',
                  url:'/api/info'
                })
              .then((response) => {
                console.log(response.data)
                that.listClass = response.data
              }).catch((error) => { // 请求失败处理
              console.log(error);
            });
      ```

  - **方法2：** 在请求axios外面定义一下 var that=this

    - ```typescript
      //用axios获取数据
            var that = this
            axios({
                  method:'get',
                  url:'/api/info'
                })
              .then(function(response){
                console.log(response.data)
                that.listClass = response.data
              }).catch(function(error){ // 请求失败处理
              console.log(error);
            });
      ```

      **参考**：[axios官方文档](http://axios-js.com/zh-cn/docs/index.html)

- **如何优雅的只在当前页面中覆盖ui库中组件的样式**

  - 熟悉webpack的人应该知道，引入的CSS文件最终都会被style-loader处理。简单来说，它的作用就是把CSS文件打包，放在style标签内，最后塞进HTML中作为一个内部样式表。不管是组件库的样式还是我们写的自定义样式都是这样处理的。
  - ![](https://s6.jpg.cm/2022/08/04/PdGEZX.jpg)

  - 我们要把组件库的样式先于自定义样式引入，这样自定义样式才能有更高的优先级。

  - 直接改组件库的CSS源码是最简单粗暴的方法。打开你项目的node_modules文件夹，一层层点开，找到对应样式文件，按照需求修改即可。个人项目这样处理确实可行，但是团队合作时，同步别人本地的node_modules就比较麻烦，只能算一个60分解法。

  - **全局CSS文件**

    之前提到，把自己写的的CSS文件放在组件库的样式后面，可以保障自定义有更高优先级。只要重写同名的样式，理论上就能实现覆盖组了。

    但这样👇处理会发现并不起作用：

    ```css
    /* src/demo.css */
    .ant-picker-calendar-date-today {
      border-color: purple; /* 覆盖为紫色 */
    }
    ```

    ```css
    // src/Demo.js
    
    // 组件库的样式
    import 'ant-design-vue/dist/antd.css'; 
    // 自定义样式
    import './demo.css'
    import { Calendar } from 'antd';
    ...
    <div className="myWrapper">
      <Calendar />
    </div>
    ```

    因为这里还涉及CSS组合选择器的优先级。

    基础的优先级应该不用赘述：`!important>内联样式>ID选择器>类选择器>标签选择器`。（!important这种hack会导致项目不好维护，不提倡使用）

    在这个基础上还有五种组合选择器要对优先级分数做累计，以类选择器为例：

    1. 后代选择器（空格）：`.A .B`选择.A元素后的所有.B元素，
    2. 子元素选择器（大于号）：`.A>.B`选择.A元素的直接后代中的.B元素
    3. 相邻兄弟选择器（加号）：`.A+.B`选择.A元素后紧邻的第一个兄弟.B元素
    4. 后续兄弟选择器(~号)：`.A~.B`选择.A元素后所有的兄弟.B元素
    5. 交集选择器（连在一起）：`.A.B`选择自身同时拥有.A和.B两个属性的元素

- **本地开发环境请求服务器接口跨域的问题**

  - 前后端分离项目需要解决第一个问题就是，前端本地开发时如何解决通过ajax请求产生的跨域的问题。一般的做法是通过本地配置nginx反向代理进行处理的，除此之外，还可以通过nodejs来进行代理接口。当然，要实现这个前提是，前端开发环境必须运行在nodejs服务中，所幸的是，现在前端的开发自动化工具都是建立在nodejs上的，所以这个前提也不是很重要。

  - 跨域指浏览器不允许当前页面的所在的源去请求另一个源的数据。源指协议，端口，域名。只要这个3个中有一个不同就是跨域。 这里列举一个经典的列子：

  - ```bash
    #协议跨域
    http://a.baidu.com访问https://a.baidu.com；
    #端口跨域
    http://a.baidu.com:8080访问http://a.baidu.com:80；
    #域名跨域
    http://a.baidu.com访问http://b.baidu.com；
    ```

    解决方案：生产环境的话还是比较推荐`nginx`的

    - 比如后端地址为`http://localhost:8080/
      那么前端在代码里只需要访问`/mall_war/*.do`就可以，默认发的是部署服务器的`ip`来访问
      然后再`nginx`里配置如下

    - ```typescript
      server {
          listen       8080;
          server_name  commonFronted;
          # 项目静态资源目录
          location / {
              alias     /xxx/dist;
              index     index.html;
          }
      
          location ^~/mall_war/ {
              proxy_pass http://localhost:8089/mall_war/;
              proxy_set_header  Host $host;
              proxy_set_header  X-Real-IP $remote_addr;
              proxy_set_header  X-Forwarded-Proto https;
              proxy_set_header  X-NginX-Proxy true;
              proxy_buffers 256 4k;
              proxy_max_temp_file_size 0k;
              proxy_connect_timeout 30;
              proxy_send_timeout 60;
              proxy_read_timeout 60;
              proxy_next_upstream error timeout invalid_header http_502;            
          }
      }
      ```

- **Vue 项目中 icon 小图标不显示**

  - 在 HTML 文件中添加了以下代码后，发现小图标还是没能呈现，应该是 Vue 项目缺少生成配置的问题

  - ```html
    <head>
    	<meta charset="utf-8">
    	<meta name="author" content="author">
    	<title>主页</title>
        <!-- 添加 favicon.ico 为网站图标(有在线.jpg, .png 文件转 .icon 工具) -->
        <link rel="Bookmark" type="image/x-icon" href="./src/assets/icon/favicon.ico" />
        <link rel="icon" type="image/x-icon" href="./src/assets/icon/favicon.ico" />
        <link rel="shortcut icon" type="image/x-icon" href="./src/assets/icon/favicon.ico" />
    </head>
    
    ```

    **解决办法：**

    在 `webpack.dev.conf.js`中新增一行 favicon 生成配置后，使用命令 `npm run dev` 重新启动 Vue 项目。

    ```typescript
    new HtmlWebpackPlugin({
          // 会自动帮你生成一个 html 文件，并且引用相关的 assets 文件(如 css, js)
          filename: 'index.html',
          // 根据自己的指定的模板文件来生成特定的 html 文件
          template: 'index.html',
          // 指定 script 位置, 默认为 true --- html 文件底部
          inject: true,
        
          // 给生成的 html 文件生成一个 favicon, 属性值为 favicon 文件所在的路径。
          favicon:'./src/assets/icon/favicon.ico'
    }),
    
    ```

    













#### 后端开发







#### 总结





### 参考资料



- 内容重点强调：个人在本次大作业中的主要贡献；完成了哪些自认为有技术含量的工作；印象深刻的一些 bug 和自己的解决方法；