# ☁️中传放心传（CUC-cloud-disk-upload-management-system）技术报告

**一个基于Vue和springboot+mybatisplus实现的文件云盘管理系统**

[![Typing SVG](https://readme-typing-svg.herokuapp.com?size=25&duration=1486&center=%E9%94%99%E8%AF%AF%E7%9A%84&vCenter=%E9%94%99%E8%AF%AF%E7%9A%84&multiline=true&height=60&lines=%E4%B8%AD%E4%BC%A0%E6%94%BE%E5%BF%83%E4%BC%A0;CUC-cloud-disk-upload-management-system)](https://git.io/typing-svg)

**作者：百川**

**负责工作：**项目整体规划、前端页面编写、后端平台搭建、具体功能修复测试

**时间：**2022.8

**前端工作日志：**[前端开发日志](https://github.com/Xuyan-cmd/CUC-cloud-disk-upload-management-system/blob/front_end/%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97.md)

**后端工作日志：**[后端开发日志](https://github.com/Xuyan-cmd/CUC-cloud-disk-upload-management-system/blob/rear_end/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97.md)

### 前言

本次小学期的实践目标是实现一个结合本专业密码学和网络安全知识体系的一个文件管理云盘系统，要求做到有文件管理的基础功能（增删改查）以外还要融入网络空间安全专业所特有的专业知识，是一次十分有意义的并且能够挖掘自身能力和一个深度学习的过程。

对于我而言，这一个多月的开发时间里，我遇到了很多的困难和知识盲区，但在这样持续学习的一个过程中，我能够深刻意识到自己对于很多知识的匮乏，因此也是这样一个契机带动着我去学习和摸索。

在最初的计划阶段，我的设想是基于老师给出的模板进行开发，但是和小组成员进行了讨论后，大家更愿意借助这样一段时间去从0开始去搭建开发，于是我们去查阅相关资料，结合我们现有的知识储备，最终决定使用当前市场主流的开发框架和工具，前端采用当前较为火遍的**Vue框架**，后端使用近几年的新锐**SpringBoot框架**。而在具体开发过程中结合密码学知识基础和要求去完成这样一个云盘文件管理系统——**中传放心传**

我对于前端开发所使用的Vue框架有一定的基础，而对于后端的接口逻辑编写和搭建只知皮毛，因此我们小组在后端的开发过程中花费相当大的学习成本，这中间出现了很多Bug和技术壁垒，我一度曾怀疑我们是否有能力在这样短的时间内去完成这样的开发，但感谢我的组员，我们始终没有退缩，最终真的从0到完整开发出成品！虽然存在很多不完美的地方和有待商榷的技术细节，但对于我们小组每一个人而言，这段时间的学习和实践是本次小学期最大的收获和意义！

### 开发内容回顾

在这个章节，我主要列出了我在整个开发过程中印象深刻的一些内容，包括部分问题的解决思路、知识学习回顾、Bug修复的方法。

**项目主体开发思路框架：**![](https://s6.jpg.cm/2022/08/03/PQMxgX.jpg)

#### 前端开发

- 对于用户注册口令信息的密码强度校验和规则设定

  - 为了确保用户注册时口令信息的安全强度，因此需要直接在用户注册时对其口令进行校验和规则设定，因此我选择结合element-ui的form表单工具和正则表达式去实现这样的功能逻辑，例如项目中我设定了用户的用户名限制在11位，口令长度8-36，其中口令只接受阿拉伯数字、英文字母、除-、_\、以外的字符，通过正则表达式去限制具体的内容。

  - ```typescript
    <el-form-item>
     <el-input
        v-model="registered.password"
        @input="checkPassLever"
        type="password"
        placeholder="请输入密码"
        onkeyup="value=value.replace(/[^\a-\z\A-\Z0-9\-\_\.]/g,'')"
        maxlength="36"
        minlength="8"
        show-word-limit
        ></el-input>
    ```

- 前端页面路由跳转问题的分析

  - 在开发前端页面过程中，出现了对于路由设定的问题，当按返回键的时候页面并没有发生变化，一开始还以为是没有监听到返回事件，但是通过测试之后发现返回事件监听成功了，路由也发生了变化，相应事件也触发了，就是页面视图没有跟着改变。

  - 原因分析：项目中路由设置的是 **hash模式**，所以对 hashchange 事件进行监听hash模式下，路由的变化会触发hashchange事件）。因此要重新在app.vue文件中重新绑定路由，从而路由不会因为重复调用而导致不能改变视图。

    - ```typescript
       mounted() {
          // 检测浏览器路由改变页面不刷新问题,hash模式的工作原理是 hashchange事件
          window.addEventListener('hashchange', () => {
          let currentPath = window.location.hash.slice(1)
          if (this.$route.path !== currentPath) {
            this.$router.push(currentPath)
          }
        }, false)
      }
      
      ```

- 使用axios访问api时出现的问题

  - **axios使用post请求服务端不能获取参数的解决方法**：

  - 项目中使用到axios作为ajax请求插件，用到post请求是常见的，但是后台说没有接收到传过去的参数，但是可以收到请求，前端检查了好几遍，浏览器的请求信息是 OK 的，请求封装也是ok的，参数都是有的，前端看是服务端的问题，服务端监测是前端的问题，这就十分抓狂。

  - 其实是axios在内部自动帮我们转换json格式数据, 也就是说，我们的 Content-Type 变成了 application/json;charset=utf-8
    然后，因为我们的参数是 JSON 对象，axios 帮我们做了一个 stringify 的处理。 而axios 使用 post 发送数据时，默认是直接把 json 放到请求体中提交到后端的。
    那么，这就与我们服务端要求的 ‘Content-Type’: ‘application/x-www-form-urlencoded’ 不符合。

    首先我尝试了给axios 头添加post请求方法的 Content-Type：

    ```typescript
    axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded'; 
    ```

    但是并没有起效果，翻了半天文档又查了一下需要序列化, qs序列化请求参数即可，当然你可以在封装请求方法的api中每次请求时作处理，我这里使用了封装axios时直接在request请求拦截器中做了处理：

    ```typescript
    import Qs from 'qs'
    axios.interceptors.request.use( (config) => {
        if (config.method=="post"){
            config.data = qs.stringify(config.data);
            config.headers['Content-Type'] = 'application/x-www-form-urlencoded';
        }
        return config;
    },  (error) => {
        return Promise.reject(error);
    });
    ```

    最后成功发送post请求，得到数据。

  - **使用axios，get数据是正常的。但是渲染数据时data一直为空解决方案：**

  - 原因;在ajax中的this会指向ajax本身，而不再是vue实例本身 ，同理，axios的then中this也不是指向vue实例本身。

  - **方法1：** 用ES6箭头函数，箭头方法可以和父方法共享变量 ( ES6中的 箭头函数 “=>” 内部的this是词法作用域，由上下文确定(也就是由外层调用者vue来确定) )

    - ```typescript
      axios({
                  method:'get',
                  url:'/api/info'
                })
              .then((response) => {
                console.log(response.data)
                that.listClass = response.data
              }).catch((error) => { // 请求失败处理
              console.log(error);
            });
      ```

  - **方法2：** 在请求axios外面定义一下 var that=this

    - ```typescript
      //用axios获取数据
            var that = this
            axios({
                  method:'get',
                  url:'/api/info'
                })
              .then(function(response){
                console.log(response.data)
                that.listClass = response.data
              }).catch(function(error){ // 请求失败处理
              console.log(error);
            });
      ```

      **参考**：[axios官方文档](http://axios-js.com/zh-cn/docs/index.html)

#### 后端开发







#### 总结



- 内容重点强调：个人在本次大作业中的主要贡献；完成了哪些自认为有技术含量的工作；印象深刻的一些 bug 和自己的解决方法；