# ☁️中传放心传（CUC-cloud-disk-upload-management-system）技术报告

**一个基于Vue和springboot+mybatisplus实现的文件云盘管理系统**

[![Typing SVG](https://readme-typing-svg.herokuapp.com?size=30&duration=1497&center=%E9%94%99%E8%AF%AF%E7%9A%84&vCenter=%E9%94%99%E8%AF%AF%E7%9A%84&multiline=true&width=620&height=70&lines=%E4%B8%AD%E4%BC%A0%E6%94%BE%E5%BF%83%E4%BC%A0;CUC-cloud-disk-upload-management-system)](https://git.io/typing-svg)

**作者：**百川🌊

**负责工作：**项目整体规划、前端页面编写、后端平台搭建、网站部署、具体功能修复测试

**时间：**2022.8

**前端工作日志**：[前端开发日志](https://github.com/Xuyan-cmd/CUC-cloud-disk-upload-management-system/blob/front_end/README.md)

**后端工作日志**：[后端开发日志](https://github.com/Xuyan-cmd/CUC-cloud-disk-upload-management-system/blob/front_end/README.md)

### 前言

本次小学期的实践目标是实现一个结合本专业密码学和网络安全知识体系的一个文件管理云盘系统，要求做到有文件管理的基础功能（增删改查）以外还要融入网络空间安全专业所特有的专业知识，是一次十分有意义的并且能够挖掘自身能力和一个深度学习的过程。

对于我而言，这一个多月的开发时间里，我遇到了很多的困难和知识盲区，但在这样持续学习的一个过程中，我能够深刻意识到自己对于很多知识的匮乏，因此也是这样一个契机带动着我去学习和摸索。

在最初的计划阶段，我的设想是基于老师给出的模板进行开发，但是和小组成员进行了讨论后，大家更愿意借助这样一段时间去从0开始去搭建开发，于是我们去查阅相关资料，结合我们现有的知识储备，最终决定使用当前市场主流的开发框架和工具，前端采用当前较为火遍的**Vue框架**，后端使用近几年的新锐**SpringBoot框架**。而在具体开发过程中结合密码学知识基础和要求去完成这样一个云盘文件管理系统——**中传放心传**

我对于前端开发所使用的Vue框架有一定的基础，而对于后端的接口逻辑编写和搭建只知皮毛，因此我们小组在后端的开发过程中花费相当大的学习成本，这中间出现了很多Bug和技术壁垒，我一度曾怀疑我们是否有能力在这样短的时间内去完成这样的开发，但感谢我的组员，我们始终没有退缩，最终真的从0到完整开发出成品！虽然存在很多不完美的地方和有待商榷的技术细节，但对于我们小组每一个人而言，这段时间的学习和实践是本次小学期最大的收获和意义！

### 开发内容回顾

在这个章节，我主要列出了我在整个开发过程中印象深刻的一些内容，包括部分问题的解决思路、知识学习回顾、Bug修复的方法。

**项目主体开发思路框架：**![](https://s6.jpg.cm/2022/08/03/PQMxgX.jpg)

#### 前端开发

- **对于用户注册口令信息的密码强度校验和规则设定**

  - 为了确保用户注册时口令信息的安全强度，因此需要直接在用户注册时对其口令进行校验和规则设定，因此我选择结合element-ui的form表单工具和正则表达式去实现这样的功能逻辑，例如项目中我设定了用户的用户名限制在11位，口令长度8-36，其中口令只接受阿拉伯数字、英文字母、除-、_\、以外的字符，通过正则表达式去限制具体的内容。

  - ```typescript
    <el-form-item>
     <el-input
        v-model="registered.password"
        @input="checkPassLever"
        type="password"
        placeholder="请输入密码"
        onkeyup="value=value.replace(/[^\a-\z\A-\Z0-9\-\_\.]/g,'')"
        maxlength="36"
        minlength="8"
        show-word-limit
        ></el-input>
    ```

- **前端页面路由跳转问题的分析**

  - 在开发前端页面过程中，出现了对于路由设定的问题，当按返回键的时候页面并没有发生变化，一开始还以为是没有监听到返回事件，但是通过测试之后发现返回事件监听成功了，路由也发生了变化，相应事件也触发了，就是页面视图没有跟着改变。

  - 原因分析：项目中路由设置的是 **hash模式**，所以对 hashchange 事件进行监听hash模式下，路由的变化会触发hashchange事件）。因此要重新在app.vue文件中重新绑定路由，从而路由不会因为重复调用而导致不能改变视图。

    - ```typescript
       mounted() {
          // 检测浏览器路由改变页面不刷新问题,hash模式的工作原理是 hashchange事件
          window.addEventListener('hashchange', () => {
          let currentPath = window.location.hash.slice(1)
          if (this.$route.path !== currentPath) {
            this.$router.push(currentPath)
          }
        }, false)
      }
      
      ```

- **使用axios访问api时出现的问题**

  - **axios使用post请求服务端不能获取参数的解决方法**：

  - 项目中使用到axios作为ajax请求插件，用到post请求是常见的，但是后台说没有接收到传过去的参数，但是可以收到请求，前端检查了好几遍，浏览器的请求信息是 OK 的，请求封装也是ok的，参数都是有的，前端看是服务端的问题，服务端监测是前端的问题，这就十分抓狂。

  - 其实是axios在内部自动帮我们转换json格式数据, 也就是说，我们的 Content-Type 变成了 application/json;charset=utf-8
    然后，因为我们的参数是 JSON 对象，axios 帮我们做了一个 stringify 的处理。 而axios 使用 post 发送数据时，默认是直接把 json 放到请求体中提交到后端的。
    那么，这就与我们服务端要求的 ‘Content-Type’: ‘application/x-www-form-urlencoded’ 不符合。

    首先我尝试了给axios 头添加post请求方法的 Content-Type：

    ```typescript
    axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded'; 
    ```

    但是并没有起效果，翻了半天文档又查了一下需要序列化, qs序列化请求参数即可，当然你可以在封装请求方法的api中每次请求时作处理，我这里使用了封装axios时直接在request请求拦截器中做了处理：

    ```typescript
    import Qs from 'qs'
    axios.interceptors.request.use( (config) => {
        if (config.method=="post"){
            config.data = qs.stringify(config.data);
            config.headers['Content-Type'] = 'application/x-www-form-urlencoded';
        }
        return config;
    },  (error) => {
        return Promise.reject(error);
    });
    ```

    最后成功发送post请求，得到数据。

  - **使用axios，get数据是正常的。但是渲染数据时data一直为空解决方案：**

  - 原因;在ajax中的this会指向ajax本身，而不再是vue实例本身 ，同理，axios的then中this也不是指向vue实例本身。

    - **方法1：** 用ES6箭头函数，箭头方法可以和父方法共享变量 ( ES6中的 箭头函数 “=>” 内部的this是词法作用域，由上下文确定(也就是由外层调用者vue来确定) )

    - ```typescript
      axios({
                  method:'get',
                  url:'/api/info'
                })
              .then((response) => {
                console.log(response.data)
                that.listClass = response.data
              }).catch((error) => { // 请求失败处理
              console.log(error);
            });
      ```

  - **方法2：** 在请求axios外面定义一下 var that=this

    - ```typescript
      //用axios获取数据
            var that = this
            axios({
                  method:'get',
                  url:'/api/info'
                })
              .then(function(response){
                console.log(response.data)
                that.listClass = response.data
              }).catch(function(error){ // 请求失败处理
              console.log(error);
            });
      ```

      **参考**：[axios官方文档](http://axios-js.com/zh-cn/docs/index.html)

- **如何优雅的只在当前页面中覆盖ui库中组件的样式**

  - 熟悉webpack的人应该知道，引入的CSS文件最终都会被style-loader处理。简单来说，它的作用就是把CSS文件打包，放在style标签内，最后塞进HTML中作为一个内部样式表。不管是组件库的样式还是我们写的自定义样式都是这样处理的。
  - ![](https://s6.jpg.cm/2022/08/04/PdGEZX.jpg)

  - 我们要把组件库的样式先于自定义样式引入，这样自定义样式才能有更高的优先级。

  - 直接改组件库的CSS源码是最简单粗暴的方法。打开你项目的node_modules文件夹，一层层点开，找到对应样式文件，按照需求修改即可。个人项目这样处理确实可行，但是团队合作时，同步别人本地的node_modules就比较麻烦，只能算一个60分解法。

  - **全局CSS文件**

    之前提到，把自己写的的CSS文件放在组件库的样式后面，可以保障自定义有更高优先级。只要重写同名的样式，理论上就能实现覆盖组了。

    但这样👇处理会发现并不起作用：

    ```css
    /* src/demo.css */
    .ant-picker-calendar-date-today {
      border-color: purple; /* 覆盖为紫色 */
    }
    ```

    ```css
    // src/Demo.js
    
    // 组件库的样式
    import 'ant-design-vue/dist/antd.css'; 
    // 自定义样式
    import './demo.css'
    import { Calendar } from 'antd';
    ...
    <div className="myWrapper">
      <Calendar />
    </div>
    ```

    因为这里还涉及CSS组合选择器的优先级。

    基础的优先级应该不用赘述：`!important>内联样式>ID选择器>类选择器>标签选择器`。（!important这种hack会导致项目不好维护，不提倡使用）

    在这个基础上还有五种组合选择器要对优先级分数做累计，以类选择器为例：

    1. 后代选择器（空格）：`.A .B`选择.A元素后的所有.B元素，
    2. 子元素选择器（大于号）：`.A>.B`选择.A元素的直接后代中的.B元素
    3. 相邻兄弟选择器（加号）：`.A+.B`选择.A元素后紧邻的第一个兄弟.B元素
    4. 后续兄弟选择器(~号)：`.A~.B`选择.A元素后所有的兄弟.B元素
    5. 交集选择器（连在一起）：`.A.B`选择自身同时拥有.A和.B两个属性的元素

- **本地开发环境请求服务器接口跨域的问题**

  - 前后端分离项目需要解决第一个问题就是，前端本地开发时如何解决通过ajax请求产生的跨域的问题。一般的做法是通过本地配置nginx反向代理进行处理的，除此之外，还可以通过nodejs来进行代理接口。当然，要实现这个前提是，前端开发环境必须运行在nodejs服务中，所幸的是，现在前端的开发自动化工具都是建立在nodejs上的，所以这个前提也不是很重要。

  - 跨域指浏览器不允许当前页面的所在的源去请求另一个源的数据。源指协议，端口，域名。只要这个3个中有一个不同就是跨域。 这里列举一个经典的列子：

  - ```bash
    #协议跨域
    http://a.baidu.com访问https://a.baidu.com；
    #端口跨域
    http://a.baidu.com:8080访问http://a.baidu.com:80；
    #域名跨域
    http://a.baidu.com访问http://b.baidu.com；
    ```

    解决方案：生产环境的话还是比较推荐`nginx`的

    - 比如后端地址为`http://localhost:8080/
      那么前端在代码里只需要访问`/mall_war/*.do`就可以，默认发的是部署服务器的`ip`来访问
      然后再`nginx`里配置如下

    - ```typescript
      server {
          listen       8080;
          server_name  commonFronted;
          # 项目静态资源目录
          location / {
              alias     /xxx/dist;
              index     index.html;
          }
      
          location ^~/mall_war/ {
              proxy_pass http://localhost:8089/mall_war/;
              proxy_set_header  Host $host;
              proxy_set_header  X-Real-IP $remote_addr;
              proxy_set_header  X-Forwarded-Proto https;
              proxy_set_header  X-NginX-Proxy true;
              proxy_buffers 256 4k;
              proxy_max_temp_file_size 0k;
              proxy_connect_timeout 30;
              proxy_send_timeout 60;
              proxy_read_timeout 60;
              proxy_next_upstream error timeout invalid_header http_502;            
          }
      }
      ```

- **Vue 项目中 icon 小图标不显示**

  - 在 HTML 文件中添加了以下代码后，发现小图标还是没能呈现，应该是 Vue 项目缺少生成配置的问题

  - ```html
    <head>
    	<meta charset="utf-8">
    	<meta name="author" content="author">
    	<title>主页</title>
        <!-- 添加 favicon.ico 为网站图标(有在线.jpg, .png 文件转 .icon 工具) -->
        <link rel="Bookmark" type="image/x-icon" href="./src/assets/icon/favicon.ico" />
        <link rel="icon" type="image/x-icon" href="./src/assets/icon/favicon.ico" />
        <link rel="shortcut icon" type="image/x-icon" href="./src/assets/icon/favicon.ico" />
    </head>
    
    ```

    **解决办法：**

    在 `webpack.dev.conf.js`中新增一行 favicon 生成配置后，使用命令 `npm run dev` 重新启动 Vue 项目。

    ```typescript
    new HtmlWebpackPlugin({
          // 会自动帮你生成一个 html 文件，并且引用相关的 assets 文件(如 css, js)
          filename: 'index.html',
          // 根据自己的指定的模板文件来生成特定的 html 文件
          template: 'index.html',
          // 指定 script 位置, 默认为 true --- html 文件底部
          inject: true,
        
          // 给生成的 html 文件生成一个 favicon, 属性值为 favicon 文件所在的路径。
          favicon:'./src/assets/icon/favicon.ico'
    }),
    
    ```


- **组件中使用定时器及销毁问题**

  - 在页面开发过程中使用了一个定时器，当从页面A跳转到页面B时，如果不手动清除这个定时器，那么它仍旧会执行，会影响到后续的渲染效果。
    这里给出我的解决办法就是，在`data`属性中定义一个`timer`，在代码中启动定时器，然后在组件销毁的时候清除定时器。具体代码如下：、

  - ```typescript
        data(){
            return{
                timer:null
            }
        },
        methods:{
            onStartTimer(){
                this.timer = setInterval( () => {
                    // 执行一些操作
                }, 1000)
            }
        },
        beforeDestroy() {
            clearInterval(this.timer);        
            this.timer = null;
        }
    ```

    但是这里有两个潜在的问题：

    1. 它需要在这个组件实例中保存这个`timer`，如果可以的话最好只有生命周期钩子可以访问到它。这并不算严重的问题，但是它可以被视为杂物。
    2. 我们的建立代码独立于我们的清理代码，这使得我们比较难于程序化地清理我们建立的所有东西。

    `Vue`官方文档给出的解决方案是，在定义timer的时候使用`$once`指令监听`beforeDestroy`这个钩子函数。在这个基础上进行改进的话：

    ```typescript
        methods:{
            onStartTimer(){
                const timer = setInterval( () => {
                    // 执行一些操作
                }, 1000)
                this.$once('hook:beforeDestroy', () => {            
                    clearInterval(timer);                                    
                })
            }
        },
    ```

    这样就解决了上面所列的两个问题。类似的这种在离开页面时需要销毁的组件都可以采用此方法。

- **在前端开发过程中，发现报如下错误：`startvaluehas mixed support,considerusingflex-startinstead`**

  - 发现是因为CSS写法不规范导致的。之前的CSS弹性盒子模型写法是这样的：

    `div{display: flex;justify-content: start;}`

    <img src="https://s6.jpg.cm/2022/08/04/PdIcnQ.png" style="zoom: 67%;" />

  - 但是这种是很早的属性值了，新的属性值应该是flex-start，如下：

    <img src="https://s6.jpg.cm/2022/08/04/PdIUJh.png" style="zoom:67%;" />

  - 此致问题解决。

    ![](https://s6.jpg.cm/2022/08/04/PdI1IW.png)

- **Vue解决报错：Emitted value instead of an instance of Error问题**

  - **重现报错提示：**

    ```bash
    (Emitted value instead of an instance of Error) <van-cell v-for=" item in this.todoList">: component lists rendered with v-for should have explicit keys. See https://vuejs.org/guide/list.html#key for more info.
    ```

    由于上述警告造成Vue项目不能启动，警告的大概意思就是在组件里面使用v-for 但是没有设置key，会造成非唯一性问题。

    针对上述问题的解决方法：

    在警告的组件里面v-for后面加一个属性key，为元素绑定了一个key，`v-for="(item, index) in this.todoList" :key="index"` 的操作，即：

    ```typescript
    <van-cell
                  v-for="(item, index) in this.todoList" :key="index"
                   :to="{ name: 'Approval/Detail', params: { id: item.businessId } }"
                >
                  <van-icon name="bell" size="30" />
                  <div class="info-right">
                    <p class="user-info">{{ item.startBy }}</p>
                    <p class="place">{{ item.processInstanceName }}</p>
                  </div>
                </van-cell>
    ```

    ![](https://s6.jpg.cm/2022/08/04/PdIhU4.jpg)

- **音乐播放器组件的编写**

  - 我们项目考虑到用户上传文件中包含音频类文件，那么对于这类文件如果需要在线预览就需要去单独编写组件去读取数据。

  - 所以在编写音乐播放器组件的时候需要考虑几点，音频文件的播放进度回调，播放速度，进度条显示等因素，需要监听当前播放的音频文件的状态信息，例如暂停播放、进度条拖动、重新播放等状态变化

  - ```typescript
    watch: {
        // 监听vuex中的当前音频播放信息
        async "$store.state.currentMusicInfo"(current) {
          this.currentMusicInfo = current;
          if (this.$store.state.isMusicPlayerShow) {
            this.$store.state.isMusicPlayerShow = false;
            this.getAudioUrl();
            await this.$store.commit("updateIsMusicPlayerShow", true);
          }
        },
    
        // 监听当前音频播放状态
        "$store.state.musicPlayState"(current) {
          // 如果不相同 说明在组件之外有地方改变了播放状态，需要将播放状态更新至此组件
          if (current != this.playState) {
            this.playState = current;
            if (current) {
              this.$refs.currentMusicPlayer.play();
            } else {
              this.$refs.currentMusicPlayer.pause();
            }
          }
        },
      },
      filters: {
        handleTime,
      },
      mounted() {},
    };
    </script>
    ```

    最终即可做出一个简易的视频播放器组件：

    ![](https://s6.jpg.cm/2022/08/04/PdqMTH.png)

- **vue-router中query参数做自动加密、解密**

  - 加密需要依赖 `crypto-js` 库，安装：

  - ```bash
    npm install crypto-js --save
    ```

    1. 将`utils`文件夹放入项目 **（最好是放在router目录下 ）** 中，在router的初始化文件中，引入`utils/query.js`的`stringifyQuery`和`parseQuery`方法，在`new VueRouter`是时候传递参数，
    2. 修改`utils/encryption.js`中的`baseCryptoCode`设置每个项目唯一的值

    ```typescript
    import Vue from "vue"
    import VueRouter from "vue-router";
    import { stringifyQuery, parseQuery } from "./utils/query";
    
    Vue.use(VueRouter);
    
    const routes = [];
    
    const router = new VueRouter({
      mode: 'history',
      base: process.env.BASE_URL,
      stringifyQuery: stringifyQuery, // 序列化query参数
      parseQuery: parseQuery, // 反序列化query参数
      routes
    });
    
    export default router
    ```

    - tils/encryption.js

      文件提供加密和解密算法（默认在index.html中已经引入了crypto-js.js）

      - getEncrypt 加密 对应的解密方法（getDecrypt）
      - getEncryptToBase64 加密后转base64 对应的解密方法（getDecryptByBase64）
      - getDecrypt 解密 对应的加密方法（getEncrypt）
      - getDecryptByBase64 对base64数据解密 先解析base64，在做解密 对应的加密方法（getEncryptToBase64）

    - utils/query.js

      文件提供了序列化和反序列化的方法

      - stringifyQuery 序列化对象并 加密
      - parseQuery 解密 反序列化对象

    反序列化

    在调用`push`的时候，会执行`this.router.match`方法，`match`方法会执行`normalizeLocation`

    `normalizeLocation`通过`resolveQuery`方法解析path中的query，传入的三个参数（path中的?之后的参数数据字符串，使用push或replace方法传递的query参数，反序列化参数的方法）

    反序列化方法会通过`router && router.options.parseQuery`获取，如果在`new VueRouter`的时候传递了`parseQuery`方法，就是用该方法，如果没有就在`resolveQuery`方法中使用默认的方法

    ```typescript
    export function normalizeLocation (
      raw: RawLocation,
      current: ?Route,
      append: ?boolean,
      router: ?VueRouter
    ): Location {
      let next: Location = typeof raw === 'string' ? { path: raw } : raw
      // named target
      if (next._normalized) {
        return next
      } else if (next.name) {
        next = extend({}, raw)
        const params = next.params
        if (params && typeof params === 'object') {
          next.params = extend({}, params)
        }
        return next
      }
    
      // relative params
      if (!next.path && next.params && current) {
        next = extend({}, next)
        next._normalized = true
        const params: any = extend(extend({}, current.params), next.params)
        if (current.name) {
          next.name = current.name
          next.params = params
        } else if (current.matched.length) {
          const rawPath = current.matched[current.matched.length - 1].path
          next.path = fillParams(rawPath, params, `path ${current.path}`)
        } else if (process.env.NODE_ENV !== 'production') {
          warn(false, `relative params navigation requires a current route.`)
        }
        return next
      }
    
      const parsedPath = parsePath(next.path || '')
      const basePath = (current && current.path) || '/'
      const path = parsedPath.path
      ? resolvePath(parsedPath.path, basePath, append || next.append)
      : basePath
    
      const query = resolveQuery(
        parsedPath.query,
        next.query,
        router && router.options.parseQuery
      )
    
      let hash = next.hash || parsedPath.hash
      if (hash && hash.charAt(0) !== '#') {
        hash = `#${hash}`
      }
    
      return {
        _normalized: true,
        path,
        query,
        hash
      }
    }
    ```

#### 后端开发

- **文件上传、下载、删除接口函数编写总结**

  - 文件的上传下载等借口，使用最多的两个类File以及MultipartFile类

  - **File类**

    ```java
    // 文件系统对象
    // 后面很多方法也用到了文件系统类的方法，比如系统创建文件的时间等，这里简称fs，后面多处都用到了
    private static final FileSystem fs = DefaultFileSystem.getFileSystem();
    
    // 路径名
    private final String path;
    
    // 枚举类型
    // file类对象的地址是否合法通过枚举类判定
    private static enum PathStatus { INVALID, CHECKED };
    
    // 文件路径是否有效
    private transient PathStatus status = null;
    // 检查路径是否有效 但只涉及nul字符，true绝对无效，false不一定有效
    final boolean isInvalid() {
        if (status == null) {
            status = (this.path.indexOf('\u0000') < 0) ? PathStatus.CHECKED
                                                       : PathStatus.INVALID;
        }
        return status == PathStatus.INVALID;
    }
    
    // 路径名前缀长度
    private final transient int prefixLength;
    int getPrefixLength() {
        return prefixLength;
    }
    
    // 依赖系统分隔符
    public static final char separatorChar = fs.getSeparator();
    // 将其转换为字符串表示
    public static final String separator = "" + separatorChar;
    
    ```

    | 函数                                     | 描述                               |
    | ---------------------------------------- | ---------------------------------- |
    | public File(String pathname)             | 创建路径名实例                     |
    | public File(String parent, String child) | 父+子路径 创建实例                 |
    | public File(URI uri)                     | 根据URI 路径创建一个新的 File 实例 |

  - **MultipartFile类**

    该接口有多个方法属性

    | 参数                  | 描述         |
    | --------------------- | ------------ |
    | getName()             | 文件格式     |
    | getOriginalFilename() | 文件名       |
    | getContentType        | 文件类型     |
    | isEmpty()             | 文件是否为空 |
    | getSize()             | 文件大小     |

  ```java
  @Override
      public List<File> getCurFiles(String dir,String id) {
          QueryWrapper<File> wrapper=new QueryWrapper<>();
          wrapper.eq("f_dir",dir);
          wrapper.eq("mem_id",id);
          //File files = baseMapper.selectById(wrapper);
          List<File> files = baseMapper.selectList(wrapper);
          return files;
      }
  
      @Override
      public File getFiles(String id) {
          QueryWrapper<File> wrapper=new QueryWrapper<>();
          wrapper.eq("id",id);
          File file = baseMapper.selectOne(wrapper);
          return file;
      }
  
      @Override
      public List<File> getFindFile(String memid,String name) {
          QueryWrapper<File> wrapper=new QueryWrapper<>();
          wrapper.eq("mem_id",memid);
          wrapper.like("name",name);
          List<File> fileList = baseMapper.selectList(wrapper);
          return fileList;
      }
  ```

- **对用户口令信息加密存储**

  **使用MD5加密来完成登录注册的验证**

  MD5加密全程是Message-Digest Algoorithm 5（信息-摘要算法），它对信息进行摘要采集，再通过一定的位运算，最终获取加密后的MD5字符串。

  MD5加密的特点主要有以下几点：

  1、针对不同长度待加密的数据、字符串等等，其都可以返回一个固定长度的MD5加密字符串。（通常32位的16进制字符串）
  2、其加密过程几乎不可逆，除非维护一个庞大的Key-Value数据库来进行碰撞破解，否则几乎无法解开。
  3、运算简便，且可实现方式多样，通过一定的处理方式也可以避免碰撞算法的破解。
  4、对于一个固定的字符串。数字等等，MD5加密后的字符串是固定的，也就是说不管MD5加密多少次，都是同样的结果。

  ```java
  //判断密码
          //因为存储到数据库密码肯定加密的
          //把输入的密码进行加密，再和数据库密码进行比较
          //加密方式 MD5
          if (!MD5.encrypt(password).equals(mobileMember.getPassword())) {
              throw new SpaceException(20001, "登录失败");
          }
          //登录成功
          //生成token字符串，使用jwt工具类
          String jwtToken = JwtUtils.getJwtToken(mobileMember.getId(), mobileMember.getNickname());
          QueryWrapper<UcenterMember> wrapper1=new QueryWrapper<>();
          wrapper1.eq("mobile",member.getMobile());
          UcenterMember ucenterMember = baseMapper.selectOne(wrapper1);
          return jwtToken;
      }
  
  ```

- 对上传文件大小进行限制



#### 网站部署和相关云服务技术使用

在完成以上前后端整体开发后，就需要将全部文件数据打包部署到线上，我们使用的是阿里云的服务，包括OSS对像存储用于文件存储，ECS云服务器部署网站，阿里的信息验证码服务，域名绑定。这也是我之前没有接触过的地方，所以在整个部署过程中也花费了大量的时间成本去学习和实践，虽然最后有部分服务的使用还存在限制，但整体已完成全部部署，也算是从头到尾浅尝了一遍阿里的云服务一条龙吧！😋

##### 服务器安装Nginx

Nginx是一款轻量级的Web服务器、反向代理服务器，由于它的内存占用少，启动极快，高并发能力强，在互联网项目中广泛应用，我们的网站部署到Nginx服务器上。当然也可以选择其它web服务器，这里我们就使用主流的Nginx。

我在阿里云购买了ECS服务器，服务器是Centos系统，故已Centos为例。

##### <img src="https://s6.jpg.cm/2022/08/04/PdLDmr.png" style="zoom:50%;" />

安装nginx相关服务：

```bash
yum install -y nginx
```

查看nginx安装目录：

```bash
whereis nginx
```

或者使用命令查看nginx版本号，出现版本号也代表安装成功。

输入命令：

```bash
nginx -v
```

修改nginx配置

此时/etc/nginx则是nginx配置文件存放位置，进入该文件夹：

<img src="https://s6.jpg.cm/2022/08/04/PdPQTp.png" style="zoom:50%;" />

上面界面我们基本上不用改什么，重要的是server这个对象，可以看到默认监听的是80端口，所以我们直接访问服务器ip即可。

此时访问时则需要带上端口号（需要服务器安全组开启8080端口）

此时按照官方文档配置好服务器实例的安全组并启动：

<img src="https://s6.jpg.cm/2022/08/04/PdPed6.png" style="zoom:50%;" />

​	新建网站文件夹

​	设置了网站存放的文件夹路径为：

```bash
/home/www/dist
```

此时我们需要在服务器上新建www文件夹：

```bash
cd /home
mkdir www
```

此处我们还没有新建`dist`文件夹，因为我们还没有把vue项目打包，打包后才会生成`dist`文件夹。

##### 打包部署vue项目

打包网站

使用vue打包命令,生成dist文件夹：

```powershell
npm run build
```

<img src="https://s6.jpg.cm/2022/08/04/PdPlYT.png" style="zoom: 33%;" />

<img src="https://s6.jpg.cm/2022/08/04/PdPbA2.png" style="zoom:33%;" />

​	上传至服务器

​	我们可以使用ftp工具将dist文件夹上传至/home/www目录下，当然也可以使用命令：

```
scp -r dist/ root@119.23.64.32:/home/www
```

在我们的项目目录下用打开git命令行，将本地的dist整个文件夹复制到服务器，需要主要的时scp命令window不支持，所以使用了git命令行工具。

此时无需重启nginx，刷新浏览器，可以看到我们的网站已经部署成功了。

<img src="https://s6.jpg.cm/2022/08/04/PdPNCO.png" style="zoom: 33%;" />

##### 解决刷新路由404问题

当我们切换路由后，然后在刷新页面，会出现404的情况。

这是因为我们vue项目采用了history的路由方式，至于原因主要是vue是单页面应用,路由的切换会由于重复调用判定失效。

解决问题的办法：

（1）将路由模式改为hash

（2）修改nginx配置：

```powershell
location / {
  try_files $uri $uri/ /index.html; ---解决页面刷新404问题
}　
```

再次重启即可解决404问题

##### 后端SpringBoot框架打包部署

- SpringBoot项目我们本次使用的是Maven集成部署，其中需要加入相关的plugins信息，如下：

  - ```typescript
    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <fork>true</fork>
                </configuration>
            </plugin>
        </plugins>
    </build>
    ```

    加入了上述信息至pom文件中

    在启动类加上`extends SpringBootServletInitializer`并重写`configure`方法。

    ```java
    @SpringBootApplication
    @ComponentScan(basePackages = {"com.chen"})
    @MapperScan("com.chen.service.mapper")
    public class AllApplication {
        public static void main(String[] args) {
            SpringApplication.run(AllApplication.class, args);
        }
    }
    ```

    就可以进行初步打包了，可以在Maven信息框中进行执行命令：

    ```java
    mvn clean package
    ```

    我们就可以在项目的target文件夹下得到一个jar包了

    ![](https://s6.jpg.cm/2022/08/04/PdP2GG.png)

    再将打包好的jar包部署到服务器端，执行命令，即可完成后端部署。

    ```bash
    java -jar *.jar
    ```

##### 域名DNS解析服务

我们首先在阿里云平台购置了域名：[cucinstall.cn](https://www.cucinstall.cn/)

完成个人信息验证后，进入DNS解析工作台配置域名解析服务，将域名绑定到项目的服务器ip地址

![](https://s6.jpg.cm/2022/08/04/PdPMGS.png)



ping一下域名，查看解析情况是否正常

![](https://s6.jpg.cm/2022/08/04/PdPOcW.png)

##### SSL证书申请和使用

我们本次使用了阿里云的SSL证书签发，采用的是RSA算法加密

![](https://s6.jpg.cm/2022/08/04/PdPZv2.png)

再在域名控制台对域名进行证书绑定

![](https://s6.jpg.cm/2022/08/04/PdREnT.png)

##### OSS存储文件使用

首先要开通ali-oss服务，并进行对应的配置，设立好需要的Bucket用来存储文件

<img src="https://s6.jpg.cm/2022/08/04/Pdq4uz.png" style="zoom:50%;" />

获得唯一的的Accesskey和对应的口令，配置在数据接口中，并与数据库进行同步

```typescript
/** 
*  上传文件，大小不能超过5GB 
* @param {string} ObjName OSS的储存路径和文件名字 
* @param {string} fileUrl 本地文件 
* @retruns Promise 
*/
export const put = async (ObjName, fileUrl) => {  
  try {    
    let result = await client.put(`${ObjName}`, fileUrl)    
    // ObjName为文件名字,可以只写名字，就直接储存在 bucket 的根路径，如需放在文件夹下面直接在文件名前面加上文件夹名称    
    return result  
  } catch (e) {    
   console.log(e)  
  }
}

// 上传成功之后，转换真实的地址
export const signatureUrl= async (ObjName) => {    
  try {        
    let result = await client.signatureUrl(`${ObjName}`)    
    return result  
  } catch (e) {    
    console.log(e)  
  }
}
```

![](https://s6.jpg.cm/2022/08/04/PdqBBu.png)

### 总结反思

### 参考资料



- 内容重点强调：个人在本次大作业中的主要贡献；完成了哪些自认为有技术含量的工作；印象深刻的一些 bug 和自己的解决方法；